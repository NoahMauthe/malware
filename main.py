import logging
import os
import signal
import sys
import time
from functools import partial
from multiprocessing import Queue, cpu_count, Process
from multiprocessing.connection import Listener

import analysis
import database
import settings
from filemanager import FileManager

inputs = Queue()
results = Queue()


class Cleaner:

    def __init__(self, file_manager):
        self.connection = None
        self.fm = file_manager
        self.logger = settings.get_logger('MAIN')
        self.worker = []

    def cleanup(self, signum, frame):
        self.connection.close()
        self.logger.info('Received interrupt, signalling the FileManager to stop')
        self.fm.terminate()
        self.fm.join()
        self.logger.info('FileManager finished')
        for w in self.worker:
            w.terminate()
        for w in self.worker:
            w.join()
        self.logger.info('Finished cleanup, exiting now')
        sys.exit(0)

    def run(self):
        signal.signal(signal.SIGTERM, self.cleanup)
        signal.signal(signal.SIGINT, self.cleanup)
        listener = Listener(settings.ADDRESS)
        self.connection = listener.accept()
        for i in range(cpu_count()):
            w = analysis.Worker(str(i), inputs, results)
            w.start()
            self.worker.append(w)
        while True:
            message = self.connection.recv()
            if message == 'shutdown':
                self.logger.info('Received shutdown message')
                self.cleanup(None, None)
                return


if __name__ == '__main__':
    vt, queries, csv = settings.init()
    fm = FileManager(inputs, results, vt, queries)
    rows = database.create()
    if rows == 0:
        database.populate(csv)
    fm.start()
    cl = Cleaner(fm)
    cl.run()
