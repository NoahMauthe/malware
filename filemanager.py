import os
import shlex
import shutil
import signal
import subprocess
import sys
import tempfile
import time
from multiprocessing import Process, cpu_count

import database
import settings
import virustotal


class FileManager(Process):

    def __init__(self, input_queue, result_queue, control_queue, run, vt, queries=None, vt_quota_used=0):
        super(FileManager, self).__init__(name=f'[Analysis] FileManager')
        signal.signal(signal.SIGTERM, self.handle_exit)
        self.logger = settings.get_logger('filemanager')
        self.queries = []
        if queries:
            with open(queries, 'r') as query_file:
                for line in query_file:
                    self.queries.append(settings.BASE_QUERY + ' ' + line.strip() + ';' if line[-1] != ';' else '')
        else:
            self.queries.append(settings.BASE_QUERY + ';')
        self.query_position = 0
        query = self.queries[self.query_position]
        self.entries = database.access(query)
        self.logger.info(f'Using query {self.query_position}:\n\t"{query}"')
        self.input = input_queue
        self.results = result_queue
        self.control = control_queue
        self.active = 0
        self.prep = cpu_count()
        self.vt = vt
        self.last_times = []
        self.time_index = 0
        self.vt_total = vt_quota_used
        self.start_time = time.monotonic_ns()
        self.analyzed = 0
        self.failed = 0
        self.current = 0
        self.run_path = run
        self.startup = True

    def handle_exit(self, *args):
        total = self.active
        self.logger.info(f'Waiting for {total} files to finish analysis')
        for i in range(total):
            self._remove()
            self.logger.log(settings.VERBOSE, f'{i + 1} of {total} files finished')
        self.logger.info('All files terminated, exiting now')
        sys.exit(0)

    def _remove(self):
        sha256, tmpdir = self.results.get()
        self.active -= 1
        if self.check_vt() and sha256:
            query = virustotal.Query(sha256)
            query.start()
        if sha256:
            self.analyzed += 1
            if self.analyzed % 10 == 0:
                self.logger.log(settings.STATUS, f'Processed {self.analyzed + self.failed} apks.')
                self.logger.log(settings.STATUS,
                                f'Successful: {self.analyzed} ('
                                f'{(self.analyzed * 100) / (self.analyzed + self.failed):.2f} %), '
                                f'Failed: {self.failed} ({(self.failed * 100) / (self.analyzed + self.failed):.2f} %)')
                self.logger.log(settings.STATUS,
                                f'Current query ({self.current} analyzed]:\n\t{self.queries[self.query_position]}')
        else:
            self.failed += 1
        if not tmpdir:
            self.logger.error(f'Directory {tmpdir} is not a directory')
            return
        tmpdir = os.path.abspath(tmpdir)
        if tmpdir.startswith('/tmp/'):
            self.logger.log(settings.VERBOSE, f'Deleting {tmpdir}')
            try:
                shutil.rmtree(tmpdir)
            except Exception as error:
                self.logger.error(f'Failed removing {tmpdir}:\n\t{repr(error)}')
        else:
            self.logger.error(f'Directory {tmpdir} is not a temporary directory')

    def run(self):
        for i in range(self.prep):
            try:
                self._download()
            except StopIteration:
                self.out_of_queries()
                return
        while True:
            self._remove()
            try:
                self._download()
            except StopIteration:
                self.out_of_queries()
                self._download()

    def out_of_queries(self):
        self.logger.info(f'No more entries found for query {self.query_position}:'
                         f'\n\t"{self.queries[self.query_position]}"')
        self.query_position += 1
        try:
            query = self.queries[self.query_position]
            self.logger.log(settings.VERBOSE, f'Continuing with query {self.query_position}:\n\t"{query}"')
            self.entries = None
            self.entries = database.access(query)
            self.current = 0
        except IndexError:
            self.logger.info('No more queries found, initializing exit')
            self.control.put('shutdown')

    def _download(self, timeout=0):
        if not os.path.exists(self.run_path):
            self.control.put('shutdown')
            return
        if not self.startup:
            time.sleep(timeout)
        tmpdir = tempfile.mkdtemp()
        sha256 = next(self.entries)[0]
        self.logger.log(settings.VERBOSE, f'Downloading {sha256}')
        try:
            output = subprocess.check_output(shlex.split(
                f'curl -s -S -O --remote-header-name -G -d apikey={settings.ANDROZOO_API_KEY} -d sha256={sha256}'
                f' https://androzoo.uni.lu/api/download'), cwd=tmpdir)
            self.startup = False
            self.logger.log(settings.VERBOSE, output)
        except KeyboardInterrupt:
            signal.raise_signal(signal.SIGTERM)
            return
        except subprocess.CalledProcessError as e:
            self.logger.error(f'Failed to download {sha256} with error code {e.returncode}:\n\t{str(e.output)}')
            self._download(timeout=max(timeout,1) * 2)
            return
        self.logger.debug(f'Successfully downloaded {sha256}')
        entry = (sha256, tmpdir)
        self.input.put(entry)
        self.active += 1

    def check_vt(self):
        if not self.vt:
            return False
        now = time.monotonic_ns()
        if self.vt_total >= 500:
            if now - self.start_time > 86400000000000:
                self.vt_total = 0
                self.start_time = now
            else:
                return False
        if len(self.last_times) < 4:
            self.last_times.append(now)
            self.vt_total += 1
            return True
        if now - self.last_times[self.time_index] > 60000000000:
            self.last_times[self.time_index] = now
            self.time_index = (self.time_index + 1) % 4
            self.vt_total += 1
            return True
        return False
