import shlex
import shutil
import signal
import subprocess
import sys
import tempfile
import time

import virustotal
from multiprocessing import Process, cpu_count, RLock
from multiprocessing.connection import Client

import database
import settings


class FileManager(Process):

    def __init__(self, input_queue, result_queue, vt, queries=None, prepare=cpu_count()):
        super(FileManager, self).__init__(name=f'[Analysis] FileManager')
        signal.signal(signal.SIGTERM, self.handle_exit)
        self.queries = []
        if queries:
            with open(queries, 'r') as query_file:
                for line in query_file:
                    self.queries.append(settings.BASE_QUERY + ' ' + line.strip() + ';' if line[-1] != ';' else '')
        else:
            self.queries.append(settings.BASE_QUERY + ';')
        self.query_position = 0
        self.entries = database.access(self.queries[self.query_position])
        self.input = input_queue
        self.results = result_queue
        self.active = 0
        self.logger = settings.get_logger('filemanager')
        self.prep = prepare
        self.vt = vt
        self.last_times = []
        self.time_index = 0
        self.vt_total = 0
        self.start_time = time.monotonic()

    def handle_exit(self, *args):
        total = self.active
        self.logger.info(f'Waiting for {total} workers to finish')
        for i in range(total):
            self._remove()
            self.logger.log(settings.VERBOSE, f'{i + 1} of {total} workers finished')
        self.logger.info('All workers terminated, exiting now')
        sys.exit(0)

    def _remove(self):
        sha256, tmpdir = self.results.get()
        self.active -= 1
        if self.check_vt() and sha256:
            query = virustotal.Query(sha256)
            query.start()
        if tmpdir.startswith('/tmp/'):
            self.logger.log(settings.VERBOSE, f'Deleting {tmpdir}')
            shutil.rmtree(tmpdir)
        else:
            self.logger.error(f'Directory {tmpdir} is not a temporary directory')

    def run(self):
        connection = Client(settings.ADDRESS)
        for i in range(self.prep):
            try:
                self._download()
            except StopIteration:
                self.out_of_queries(connection)
                return
        while True:
            self._remove()
            try:
                self._download()
            except StopIteration:
                self.out_of_queries(connection)
                break

    def out_of_queries(self, connection):
        self.logger.info(f'No more entries found for query {self.query_position}:'
                         f'\n\t"{self.queries[self.query_position]}"')
        self.query_position += 1
        try:
            self.entries = database.access(self.queries[self.query_position])
        except IndexError:
            self.logger.info('No more queries found, initializing exit')
            connection.send('shutdown')

    def _download(self):
        tmpdir = tempfile.mkdtemp()
        sha256 = next(self.entries)[0]
        self.logger.log(settings.VERBOSE, f'Downloading {sha256}')
        try:
            ret_code = subprocess.check_call(shlex.split(
                f'curl -s -S -O --remote-header-name -G -d apikey={settings.ANDROZOO_API_KEY} -d sha256={sha256}'
                f' https://androzoo.uni.lu/api/download'), cwd=tmpdir)
        except KeyboardInterrupt:
            signal.raise_signal(signal.SIGTERM)
            return
        except subprocess.CalledProcessError:
            ret_code = -1
        if ret_code != 0:
            self.logger.error(f'Failed to download {sha256}')
            self._download()
        else:
            self.logger.log(settings.VERBOSE, f'Successfully downloaded {sha256}')
            self.input.put((sha256, tmpdir))
            self.active += 1

    def check_vt(self):
        if not self.vt:
            return False
        now = time.monotonic()
        if self.vt_total > 500:
            if now - self.start_time > 86400:
                self.vt_total = 0
            else:
                return False
        if len(self.last_times) < 4:
            self.last_times.append(now)
            self.vt_total += 1
            return True
        if now - self.last_times[self.time_index] > 60:
            self.last_times[self.time_index] = now
            self.time_index = (self.time_index + 1) % 4
            self.vt_total += 1
            return True
        return False


